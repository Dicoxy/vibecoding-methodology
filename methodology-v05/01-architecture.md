# Блок 1: Архитектура системы

*Статус: ✅ Готов (базовая версия)*
*Последнее обновление: 17 февраля 2026*

---

## 1.1 Участники

Четыре участника, жёсткая иерархия принятия решений.

**Принцип заменяемости инструментов:** конкретные модели (DeepSeek, Sonnet, Opus) и инструменты (Claude Code, Cline, Cursor) — заменяемы. Структура ролей и взаимодействий — нет. Сегодня кодер — DeepSeek, завтра — другая модель или бинарный генератор. Архитектура не меняется.

### Человек-архитектор

```
Роль: оператор проекта, финальное слово
Делает:
  - Определяет ЦЕЛЬ проекта (GOAL.md)
  - Бизнес-решения (что строим, для кого, зачем)
  - Утверждает декомпозицию и контракты
  - Вмешивается на уровне логики и мета-мышления
  - Принимает финальный результат
  - Всегда в цикле — ни одно ключевое решение без него

НЕ делает:
  - Не пишет код
  - Не лезет в реализацию
  - Не дебажит (это задача агентов и оркестратора)
```

### Оркестратор (Claude Max/Opus в claude.ai + MCP)

```
Роль: стратегический партнёр человека, мозг системы
Делает:
  - Превращает ЦЕЛЬ человека в измеримые критерии (GOAL.md)
  - Декомпозиция проекта на блоки по SPEC.md
  - Генерация контрактов для каждого блока (включая цель блока)
  - Проверка что контракты стыкуются
  - Раздача задач агентам (генерирует готовые промпты)
  - Диагностика: какой блок сломался, почему
  - Управление shared state (часть роли оркестратора)
  - Видит GitHub через MCP (коммиты, ветки, статусы)
  - Ищет в RAG-базе changelog

НЕ делает:
  - Не пишет код
  - Не видит реализацию — только контракты и статусы
  - Не принимает бизнес-решения (это человек)

Память между сессиями:
  GOAL.md          — куда идём (измеримые критерии)
  BLOCKS.md        — что делаем (граф блоков)
  contracts/       — как стыкуются (интерфейсы)
  changelog + RAG  — что реально сделано (факты)
  
  Каждую сессию начинает с чтения через MCP.

Ограничения:
  - Работает для Tier 2 (8-15 блоков) уверенно
  - Tier 3 (40+ блоков) — нужен механизм разгрузки контекста
    (загружать только актуальные блоки, не весь граф)
```

### Агенты-исполнители

```
Роль: руки системы
Конкретные инструменты заменяемы (сейчас Claude Code, Cline, Cursor).
Структура агента — нет:

  ┌── Кодер (дешёвая модель)
  │     Задача: написать код по CONTRACT.md
  │
  ├── Ревьюер + Валидатор (средняя модель)
  │     Задача: проверить ПОВЕДЕНИЕ блока, не код
  │     Проверяет:
  │       - Соответствие контракту (вход/выход)
  │       - Отсутствие багов
  │       - Метрики качества (скорость, корректность, граничные случаи)
  │       - Микросимуляция: эмулирует вход → проверяет выход
  │     НЕ проверяет:
  │       - Стиль кода
  │       - Именование переменных
  │       - "Как бы я написал"
  │
  └── Фоллбэк (мощная модель)
        Задача: разобраться в сложном случае
        Триггер: ревьюер не смог за 2 итерации
        Подключается в ~5% случаев

Каждый агент также:
  - Пишет changelog по жёстким правилам (см. раздел 1.4)
  - Коммитит в свою ветку block/[название]
  
НЕ делает:
  - Не планирует
  - Не принимает архитектурных решений
  - Не трогает чужие файлы
  
Получает от оркестратора:
  - CLAUDE.md (общий контекст проекта)
  - CONTRACT.md своего блока (с ЦЕЛЬЮ блока)
  - CONTRACT.md зависимостей (только интерфейсы, не код!)
  - Дизайн/мокап (если есть)
  - Правила changelog-а

НЕ получает:
  - Код других блоков
  - Всю спецификацию проекта
  - Историю обсуждений с оркестратором
```

### RAG-база (пассивный компонент)

```
Роль: память системы
Делает:
  - Индексирует changelog-записи всех агентов
  - Отвечает на поисковые запросы

Кто пользуется:
  - Оркестратор: "все изменения за сегодня", "статус блока X"
  - Человек: "что реально работает прямо сейчас"
  - Агент при дебаге: "что менялось в блоке, от которого я завишу"

Инфраструктура: финский сервер (существующая инфраструктура)
```

---

## 1.2 Взаимодействия

### Человек ↔ Оркестратор

```
Человек → Оркестратор:
  - Цель проекта (что хочу видеть на выходе)
  - SPEC.md (что строим)
  - Бриф, контент, референсы
  - Утверждения / отклонения
  - Вопросы на уровне логики ("почему так?")

Оркестратор → Человек:
  - GOAL.md (цель → измеримые критерии)
  - BLOCKS.md (граф блоков)
  - contracts/* (контракты)
  - Диагностика проблем
  - Вопросы, требующие бизнес-решения
  - Готовые промпты для агентов
  - Статус проекта (через MCP → GitHub)

Формат: диалог в claude.ai
Частота: на старте, при проблемах, при приёмке
```

### Оркестратор → Агент-исполнитель

```
Текущий режим:
  1. Оркестратор генерирует готовый промпт для агента
  2. Человек копирует промпт в терминал (Claude Code / Cline / Cursor)
  3. Агент работает
  4. Результат → GitHub (ветка block/*)
  5. Оркестратор видит результат через MCP

Будущая автоматизация:
  - Промпты сохраняются в GitHub
  - Агенты подтягивают задачи автоматически
```

### Агент → Результат → Система

```
Агент создаёт:
  1. Код в ветке block/[название]
  2. Тесты (проверяющие поведение, не реализацию)
  3. Changelog-запись (стандартный формат, см. 1.4)
  4. Коммит с описательным сообщением

Далее:
  - Changelog автоматически индексируется в RAG
  - Оркестратор видит коммит через MCP
  - Человек проверяет, мёржит
```

### Полная схема

```
                    ЧЕЛОВЕК
                    │
                    │ цель, решения, утверждения, мета-мышление
                    ▼
               ОРКЕСТРАТОР (Claude Max + MCP)
                    │
                    ├──→ читает: GOAL.md, BLOCKS.md, contracts/
                    ├──→ видит: GitHub ветки, коммиты (MCP)
                    ├──→ ищет: RAG-база changelog (MCP)
                    │
                    ├──→ промпт → Агент 1 (блок A)
                    ├──→ промпт → Агент 2 (блок B)
                    └──→ промпт → Агент 3 (блок C)
                              │          │          │
                              ▼          ▼          ▼
                           код+тесты  код+тесты  код+тесты
                              │          │          │
                              ├─→ GitHub (ветки block/*)
                              └─→ Changelog → RAG-база
```

---

## 1.3 Файловая структура проекта

### Якоря системы (4 слоя)

```
GOAL.md          — куда идём (измеримые критерии финального результата)
  ↓                Цель проверяет: правильную ли систему мы строим?
BLOCKS.md        — что делаем (граф блоков, слои, зависимости)
  ↓                Структура проверяет: все ли части на месте?
contracts/       — как стыкуются (вход/выход/цель каждого блока)
  ↓                Контракты проверяют: совместимы ли блоки?
changelog/       — что реально сделано → индексируется в RAG
                   Факты проверяют: соответствует ли реализация плану?
```

### Структура методологии

```
methodology-v05/
├── INDEX.md              ← оглавление, читается первым
├── 01-architecture.md    ← этот файл
├── 02-decomposition.md   ← блоки, контракты, графы
├── 03-changelog-rag.md   ← документирование, RAG
├── 04-validation.md      ← ситуации, ошибки, метрики
├── 05-process.md         ← фазы, git, тестирование, дизайн
└── cases/                ← будущее: реальные кейсы из проектов
```

---

## 1.4 Формат changelog-а

Следует принципу Манифеста: **документирование до, а не после.**

Changelog-запись создаётся в ДВА этапа:

### Этап 1: ДО начала работы (план)

```markdown
## [block-name] | [YYYY-MM-DD] | [агент] | ПЛАН

### Цель блока
- [цель из CONTRACT.md — зачем этот блок существует]

### Что планируем сделать
- [конкретно что будет реализовано]

### Контракт
- Вход: contracts/[name].md v[N]
- Выход: [ожидаемое]

### Ожидаемые метрики
- [что будем проверять]
```

### Этап 2: ПОСЛЕ завершения (факт)

```markdown
## [block-name] | [YYYY-MM-DD] | [агент] | ФАКТ

### Сделано
- [конкретно что реализовано]

### Контракт
- Вход: соответствует contracts/[name].md v[N] ✅/❌
- Выход: [описание] ✅/❌

### Тесты (поведение)
- [вход X → выход Y]: ✅/❌
- [граничный случай]: ✅/❌
- [метрика скорости]: ✅/❌

### Отклонения от плана
- [если есть — что пошло не так и почему]
```

### Правила

```
1. ПЛАН пишется ДО начала работы — фиксирует намерение
2. ФАКТ пишется ПОСЛЕ завершения — фиксирует результат
3. Формат СТРОГО по шаблону — иначе RAG не проиндексирует
4. Тесты описывают ПОВЕДЕНИЕ (вход → выход), не реализацию
5. Отклонения от плана обязательны — это источник обучения
6. Если блок изменяется повторно — новая пара ПЛАН/ФАКТ
```

---

*Версия 1.1 | 17 февраля 2026*
*Обновлено: сверка с Манифестом — changelog до/после, поведенческое тестирование, заменяемость инструментов*
