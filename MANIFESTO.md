# Манифест блочного кодинга

**Методология разработки, которая переживёт любую смену технологий**

*Версия 1.0 | 15 февраля 2026*
*Автор: Гриша Мелоди*

---

## Главный тезис

Код — расходный материал. Архитектура — актив.

Языки программирования появляются и исчезают. Фреймворки живут 3–5 лет. Модели ИИ обновляются каждые полгода. Но принцип правильной декомпозиции системы на независимые части с чёткими контрактами между ними — работает десятилетия и будет работать дальше.

Блочный кодинг — это методология, в которой человек проектирует *что* должна делать система, а *как* это реализовано внутри — задача исполнителя. Сегодня исполнитель пишет Python. Завтра ИИ будет генерировать оптимизированные бинарники напрямую. Методология не изменится, потому что она работает на уровне выше кода.

---

## Три роли, одна иерархия

### Архитектор — человек

Определяет блоки и контракты между ними. Принимает бизнес-решения. Отвечает на вопрос «что строим и зачем». Это единственная роль, которая не может быть автоматизирована, потому что она требует понимания контекста бизнеса, пользователей и рынка.

### Оркестратор — человек или ИИ

Собирает блоки в систему. Управляет зависимостями, проверяет стыки, добавляет адаптеры между несовместимыми блоками. Не знает, что внутри блока. Знает только контракты. Сейчас эту роль частично выполняет человек через Claude Chat, в будущем — автоматический агент.

### Реализатор — ИИ

Наполняет блок внутренней логикой. Получает контракт (вход, выход, ограничения), возвращает работающую реализацию. Сегодня это код на Python или TypeScript. Завтра — бинарный файл, сгенерированный нейросетью напрямую. Для архитектора и оркестратора разницы нет: блок либо выполняет контракт, либо нет.

---

## Блок — это контракт, а не код

Центральная абстракция методологии — блок. Блок определяется не своим содержимым, а своим поведением:

- **Что принимает на вход** — формат, типы, ограничения
- **Что отдаёт на выходе** — формат, гарантии, инварианты
- **Чего не делает** — границы ответственности

Внутри блока может быть что угодно: скрипт на Python, скомпилированный бинарник, вызов внешнего API, нейросетевая модель или ручной труд стажёра. Если контракт выполняется — блок работает. Реализация заменяема. Контракт — нет.

Это принцип, который позволяет безболезненно пережить переход от «ИИ пишет код» к «ИИ генерирует бинарники»: ты не переписываешь систему — ты переключаешь движок внутри каждого блока.

---

## Пять принципов

### 1. Спецификация — language-agnostic

Описывай *что*, а не *как*. Не «напиши функцию на Python, которая...», а «нужен сервис, который принимает X, возвращает Y, выдерживает Z запросов в секунду». Чем чище отделено намерение от реализации, тем проще переход на любую новую технологию.

### 2. Тестирование — через поведение

Проверяй не код, а результат. Не «правильный ли синтаксис», а «делает ли блок то, что обещает контракт». Контрактные тесты, нагрузочные тесты, проверка инвариантов — всё это работает одинаково, независимо от того, что внутри блока: интерпретируемый код или машинный бинарник.

### 3. Контроль качества — через метрики

Когда внутри блока бинарник, ты не можешь прочитать код. Значит, код-ревью перестаёт работать как инструмент контроля. Вместо этого: скорость отклика, потребление ресурсов, корректность выхода, устойчивость к граничным случаям. Метрики объективны и не зависят от формы реализации.

### 4. Документирование — до, а не после

CHANGELOG пишется *до* изменения: что меняем, почему, какой ожидаемый результат. Это создаёт контекст для любого исполнителя — человека или ИИ — и защищает от повторных ошибок. Решения фиксируются в момент принятия, а не восстанавливаются по памяти.

### 5. Система строится из стыков, а не из блоков

Ценность системы — не в том, насколько хорош каждый блок в отдельности, а в том, насколько надёжны соединения между ними. Ошибки живут на стыках. Если выход блока A не соответствует входу блока B — проблема локализована. Не нужно перечитывать всю систему. Нужно проверить один контракт.

---

## Runtime-agnostic: почему это важно уже сейчас

Индустрия движется к тому, что ИИ будет генерировать не исходный код, а оптимизированные исполняемые файлы напрямую. Это не вопрос «если», а вопрос «когда». Методология блочного кодинга готова к этому переходу прямо сейчас, потому что:

**Уровень проектирования полностью отделён от уровня реализации.** Архитектор работает с контрактами. Контракт не содержит ни строчки кода — только описание поведения. Когда ИИ начнёт выдавать бинарники вместо Python-скриптов, контракты останутся теми же.

**Тестирование не зависит от формата реализации.** Мы проверяем: «отправили на вход X, получили на выходе Y, уложились в Z миллисекунд». Работает одинаково для Python-модуля и для скомпилированного бинарника.

**Оркестрация работает на уровне интерфейсов.** Оркестратор не заглядывает внутрь блока. Ему нужно знать только: какой формат данных на входе, какой на выходе, сколько времени занимает выполнение. Внутренняя реализация — чёрный ящик.

Это значит, что методология, освоенная сегодня, не устареет завтра. Ты учишься проектировать системы, а не писать код. Код — это деталь реализации.

---

## Что это меняет для людей

### Для разработчиков
Путь развития — не «знать больше языков», а «лучше проектировать контракты». Навык декомпозиции системы на правильные блоки с правильными стыками — это то, что останется ценным при любом уровне автоматизации.

### Для компаний
Архитектура IT-компании важнее, чем стек технологий. Компания, построенная на чистых контрактах между компонентами, может мигрировать на любую новую технологию блок за блоком, без переписывания с нуля.

### Для обучения
Учить нужно не синтаксис, а мышление: как разбить задачу на части, как определить границы ответственности, как описать контракт так, чтобы любой исполнитель (человек или машина) мог его выполнить. Это фундамент, который не устаревает.

---

## Иерархия методологии

```
МАНИФЕСТ (этот документ)
│   Философия: почему блоки, контракты, runtime-agnostic
│   Не меняется при смене версий
│
├── МЕТОДОЛОГИЯ (methodology-vX.md)
│   │   Конкретные практики: фазы, роли, инструменты
│   │   Версионируется: v0.3 → v0.4 → v0.5
│   │
│   ├── ШАБЛОНЫ (templates/)
│   │   CONTRACT.md, SPEC.md, CLAUDE.md
│   │
│   ├── ПАТТЕРНЫ (patterns/)
│   │   Решения типовых задач
│   │
│   └── КОМПОНЕНТЫ (components/)
│       Переиспользуемые куски (сейчас React, завтра — что угодно)
│
└── ПРОЕКТЫ
    Конкретные реализации, живущие по методологии
```

Манифест — это фундамент. Методология версионируется и эволюционирует. Инструменты заменяются. Принципы остаются.

---

## Резюме в одном абзаце

Блочный кодинг — это методология, в которой системы строятся из блоков с чёткими контрактами, а не из строк кода. Человек-архитектор определяет *что* нужно, ИИ-реализатор определяет *как* это сделать. Спецификации не привязаны к языку, тесты проверяют поведение, контроль качества основан на метриках. Эта архитектура готова к любому будущему: будь то генерация кода, генерация бинарников или что-то, чего мы пока не можем представить. Потому что правильная декомпозиция и чистые контракты — это не про технологию. Это про мышление.

---

*Блочный кодинг — проектируй систему, а не код.*
